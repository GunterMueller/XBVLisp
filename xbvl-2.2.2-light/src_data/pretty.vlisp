; ------ pretty-print, par [pg]
;        18-Jan-82 : prettyfie les fonctions tracees.
;	modifie par [hw], Jan. 1983
;	soit-dit en passant : y'a plus aucune raison speciale pour
; 	la trace, par contre, pour les commentaires, la, oui....

(setq --x-- careful careful nil)
(princ "je charge pretty.vlisp")
(package pretty)
(de e ()(sh "emacs /usr/local/src/xbvlisp/src/pretty.vlisp")
	(load "/usr/local/src/xbvlisp/src/pretty.vlisp"))

(de pterpri (n)(if (> (outpos) lmargin)(terpri n)))

(setq ARGH ())
(df |allpretty (l ARGH)
   (setq ARGH t)
   (|mapc l (lambda (f) (terpri) (pprint f)))
   (setq ARGH ()))

(df |pretty (l ARGH)
  (|mapc l (lambda (f) (terpri) (pprint f)))
  )

(de pprint (f ;; x)
  (status print 3)      ; bit 0 : '"' , bit 1 : pas d'espace.
  (setq lmargin 0)
  (setq x (cdr (assoc (ftyp f) '((7 . de) (8 . df) (9 . dm)))))
  (and x (|p-p [x f . (fval f)]))
  (terpri)
  (le_tout f)
  (status print 0)
  f)

(de trouve_le (x y)
  (if x (if (eq (caar x) y)(cddar x)(self (cdr x) y))))

(de le_tout (x)
  (when (get x 'example)(terpri)(t+3)
	(if ARGH (progn (princh "(")(prin1 '|example)(princh " ")
			((if ARGH 'extprin1 'prin1) ['quote x])(princh " '(")(terpri))
	(print "exemples:"))
	(|mapc (get x 'example)(lambda (x)(|p-p x)(terpri)))
	(when ARGH (princh ")")(princh ")"))
	(t-3)(terpri))
  (let ((y (get x 'entree)))
  	(when y (let ((y (trouve_le y '|assert-ent)))
	   (when y (t+3)
		(if (null ARGH)	(print "assertion d'entree:")
		   (princh "(")(prin1 '|assert-entree)(princh " ")
		   ((if ARGH 'extprint 'print)  ['quote x]))
		(|mapc y (lambda (y)(|p-p y)(terpri)))
		(if ARGH (princh ")"))
		(t-3)(terpri))))
	(while y (if (memq (caar y) '(|assert-ent |%%aux |%trac)) (nextl y)
		(t+3)
		(if (null ARGH)	(print "activite d'entree:")
		   (princh "(")(prin1 '|entree)(princh " ")
		   ((if ARGH 'extprint 'print)  ['quote x]))
	        (|p-p (if ARGH ['quote (nextl y)] (nextl y)))
		(terpri)
		(if ARGH (princh ")"))
		(t-3)(terpri)))
)
  (let ((y (get x 'sortie)))
	(when y (let ((y (trouve_le y '|assert-sor)))
	  (when y (t+3)
		(if (null ARGH)(print "assertion de sortie:")
		    (princh "(")(prin1 '|assert-sortie)(princh " ")
		    ((if ARGH 'extprint 'print) ['quote x]))
		(|mapc y (lambda (y)(|p-p y)(terpri)))
		(if ARGH (princh ")"))
		(t-3)(terpri))))
	(while y (if (memq (caar y) '(|%trac |assert-sor)) (nextl y)
		(t+3)
		(if (null ARGH)	(print "activite de sortie:")
		   (princh "(")(prin1 '|sortie)(princh " ")
		   ((if ARGH 'extprint 'print)  ['quote x]))
	        (|p-p (if ARGH ['quote (nextl y)] (nextl y)))
		(terpri)
		(if ARGH (princh ")"))
		(t-3)(terpri)))
))

(de |p-p (l ;; x xx) (cond
  ((null l) (princh "()"))
  ((atom l) ((if ARGH 'extprin1 'prin1) l))
  ((and (eq (car l) quote) (null (cddr l)))
   (princh "'") (|p-p (cadr l)))
  (t ;(when (and (listp (car l)) (eq (caar l) lambda))
      (setq xx (outpos)) (princh "(") 
	        (p-commcdr (getcdr l))
		(if (getcar l)(let ((y (getcar l))(z l))
					(setq l z)
					(p-comm t '|PCOM)
					(setq l z)(|p-p (car l))
					(p-comm t '|COM)
					(setq l z))
		    (|p-p (car l)))
                ; attention a un non-atome en tete
     (selectq (and (litatom (setq x (nextl l))) (get x 'ptyp))
        (1 ; format PROGN ; (p-progn))
        (2 ; format WHILE ; (p-p1) (p-progn t))
        (3 ; format DEF   ; (p-p1) (p-p1) (p-progn t))
        (4 ; format COND  ; (p-cond))
        (5 ; format SELECTQ ; (p-p1) (p-cond))
        (t ; format standard ;
          (t+3) (while (listp l) (p-p1)) (t-3)))
      (and l (princh " . ") (princh l))
      (princh ")"))))

(de p-p1 () (princh " ")
	(p-commcdr (getcdr l))
	(if (getcar l)(let ((y (prog1 l (nextl l)))(z l))
			(setq l y)(p-comm t '|PCOM)
			(setq l y)(|p-p (car y))(p-comm t '|COM)(setq l z))
	 (|p-p (nextl l))))

(de t+3 () (setq lmargin (+ lmargin 3)))
(de t-3 () (setq lmargin (- lmargin 3)))

(de p-progn (+++)
  (if (and (null (cdr l)) (null +++))
      (p-p1)    ; un seul argument
      (t+3)     ; plusieurs
      (while (listp l)
             (if (> lmargin (outpos)) (outpos lmargin)
                 (terpri))
	(p-commcdr (getcdr l))
	(if (getcar l)(let ((y (prog1 l (nextl l)))(z l))
			(setq l y)(p-comm t '|PCOM)
			(|p-p (car y)) (p-comm t '|COM)(setq l z))
             (|p-p (nextl l))))
      (t-3)))

(de p-cond ()
  (t+3)
  (while (listp l)
    (pterpri)
    (princh "(")
    (p-commcdr (getcdr l))
    (if (null (car l))(progn (nextl l)(princh ")"))
    (if (getcar l)(let ((y (prog1 l (nextl l)))(l nil))
		     	(setq l (car y))
        (p-commcdr (getcdr l))
	(if (getcar l)(let ((y (prog1 l (nextl l)))(z l))
			(setq l y)(p-comm t '|PCOM)
			(|p-p (car y))(p-comm t '|COM)(setq l z))
             (|p-p (nextl l)))
		(p-commcdr (getcdr l))
		(if l (p-progn))(princh ")")(pterpri)
		(setq l y)(p-comm t))
    (let (l (nextl l))
	(p-commcdr (getcdr l))
	(if (getcar l)(let ((y (prog1 l (nextl l)))(z l))
			(setq l y)(p-comm t '|PCOM)
			(|p-p (car y))(p-comm t '|COM)(setq l z))
             (|p-p (nextl l)))
        (if l (p-progn))(princh ")")))))
  (t-3))

(de p-comm (-x- COMMENT -y- -Z-)(setq -y- t)(p-comm1 -x-)
   (when (and -Z- (eq COMMENT '|PCOM)) (princh " ")))

(de p-comm1 (-x-)
	(let ((z (getcar l)) (o-argh ARGH))
		(setq z (cdr z))
		(status print 2)
		(let ((-z- (getcar z))(-y- l))
		      (if -z- (progn (t+3)(p-comm1 (setq l z))
					(setq l -y-)(t-3))))
		(while z (if (equal (car z) COMMENT)
			    (progn 
		(princh (if (and -y- (eq COMMENT '|PCOM)) 
			    (progn (setq -y- ()) ";") " ;"))
			(let ((INDICATEUR (status print)))
				(status print 2)
			        (|p-p (cadr z))
				(status print INDICATEUR))
			        (setq -Z- t)
				(setq z (cddr z))(princh ";"))
			    (setq z (cddr z))))
		(when (and ARGH (eq COMMENT '|COM))
		(setq z (cdr (getcar l))) (status print 3)
		(let ()
			(when (memq (car z) '(|PCOM |COM)) (setq z (cddr z))
				(self)))
		(if (null z)(if (> (outpos) lmargin)(terpri))
		    (t+3)(terpri)(outpos(1-(outpos)))(princh "{")
                (if ARGH (setq ARGH nil))
		(while z (if (memq (car z) '(|PCOM |COM)) (setq z (cddr z))
		     (|p-p (nextl z))(princh " ")
;(if (getcar (car z))(let ((w l)) (setq l (car z))(|p-p (car z))
;(p-comm1 t)(setq l w)(nextl z))
			(|p-p (nextl z))
			(if z (if (> (outpos) lmargin)(terpri)(princh " ")))))
		(princh "}")
                (setq ARGH o-argh)
                (t-3)(if(> (outpos) lmargin)(terpri))))
		(status print 3))))

(de p-commcdr (z)
	(let ((z (cdr z))(l))
		(if (or (null z)(null ARGH))() 
		   (while z (t+3)(if (> (outpos) 0)(terpri))
		     (princh "{")
		     (setq ARGH nil)
		     (status print 2)
		     (|p-p "cdr : ")(status print 3)
		     (|p-p (nextl z))(terpri)
		     (|mapc (nextl z)(lambda (x)(|p-p x)))
		     (princh "}")
		     (setq ARGH t)
		     (t-3))(terpri))))

(|mapc '(progn           ; type progn
  prog1 and exit or) (lambda (x) (put x 'ptyp 1)))

(|mapc '(lambda          ; type lambda
  letf when
  escape if ifn let |mapc |mapcar while until) (lambda (x) (put x 'ptyp 2)))

(|mapc '(de              ; type def
  df dm dmc) (lambda (x) (put x 'ptyp 3)))

(|mapc '(cond            ; type cond
  ) (lambda (x) (put x 'ptyp 4)))

(|mapc '(selectq         ; type selectq
  ) (lambda (x) (put x 'ptyp 5)))

(|mapc '(setq            ; type setq multiple
  ) (lambda (x) (put x 'ptyp 6)))

(package)

(print "pretty.vlisp charge")

(setq careful --x--)
